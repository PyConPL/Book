\usemodule[pycon-2015]
\starttext

\Title{Teoria Kolejek - matematyka i efektywne wytwarzanie oprogramowania}
\Author{Wiktor Żołnowski}
\MakeTitlePage

Przez ostatnich kilka lat, pomagając różnym organizacjom jako Agile
Coach i niezależny konsultant zauważyłem, że często ta sama metoda
wytwarzania oprogramowania w niektórych organizacjach i zespołach
działa, a w innych nie. Podobnie, zbierając materiały do książki
\quotation{Mity i Problemy w Agile} podczas organizowanych przez nas
spotkań z cyklu Bring Your Own Problem, wielokrotnie słyszałem
wypowiedzi uczestników, którzy stosując podobne podejścia osiągali
zaskakująco różne efekty. By odkryć, dlaczego tak się dzieje, próbowałem
również przypomnieć sobie, jak to było, gdy sam pracowałem jako QA i
developer w zespołach, które, przynajmniej według mojej subiektywnej
oceny, działały bardzo sprawnie i efektywnie. Poza oczywistymi
różnicami, takimi jak na przykład to, że w każdym zespole byli inni
ludzie oraz działali oni w kontekście innych organizacji, ciężko było mi
znaleźć ogólne czynniki, które mogłyby mieć realny wpływ na to, dlaczego
dany zespół wykazywał się lepszą efektywnością i przewidywalnością oraz
rozwijał się znacznie szybciej niż inne. Do czasu aż zupełnie
przypadkiem, szukając informacji na temat tego, jak policzyć maksymalną
wydajność jednego z budowanych przez nas systemów odświeżałem sobie
informacje na temat Teorii Kolejek i Prawa Little'a\ldots{}

\subsection[podstawy-teorii-kolejek-i-prawo-littlea]{Podstawy Teorii
Kolejek i Prawo Little'a}

Dlaczego akurat Teoria Kolejek? Coraz częściej mamy do czynienia z
systemami przetwarzającymi duże ilości danych, komunikującyim się z
innymi systemami, czy też po prostu działającymi asynchronicznie. W
takich systemach stosuje się różnego typu kolejki (mniej lub bardziej
bezpośrednio - w końcu komputery, procesory, RAM, czy dyski twarde też
działają w oparciu kolejki). W takich systemach można, na podstawie
danych, które zazwyczaj jesteśmy w stanie zebrać, oszacować na podstawie
wzorów zaczerpniętych z Teorii Kolejek maksymalne obciążenie systemu,
czy też policzyć czasy przetwarzania dużej ilości danych w zależności od
liczby procesów lub wątków. Jest to temat bardzo szeroki i poświęcono mu
już całe książki i prace naukowe.

W moim przypadku teoria ta znalazła zastosowanie do czegoś innego. Takim
(nie)typowym systemem kolejkowym jest przecież zespół developerski, do
którego spływają wymagania. Jak by nie było, wymagania te, czy to w
postaci karteczek na tablicy, stories w Jirze, czy tasków w Trello,
układają się w kolejki.

Pomocne w zrozumieniu tego, dlaczego dany proces/system działa, a inny
nie, okazało się również Prawo Little'a mówiące o tym, że średnia liczba
rzeczy/klientów w systemie jest równa iloczynowi średniego czasu
przebywania w systemie oraz średniego tempa ich przybywania.

\subsection[dlaczego-scrum-i-kanban-czy-jakikolwiek-inny-proces-wytwarzania-oprogramowania-działają]{Dlaczego
Scrum i Kanban (czy jakikolwiek inny proces wytwarzania oprogramowania)
działają?}

Jako Agile Coach miałem już na koncie kilka udanych wdrożeń Scrum i
Kanban w różnych zespołach. Oczywiście wiedziałem, jak istotny w Scrum
jest Sprint Planning oraz Backlog Refinement. Wiedziałem też, że
kluczowym czynnikiem efektywnego zastosowania Kanban jest zastosowanie
limitu Work in Process (WIP). Wiedza o tym, co jest kluczowe do
działania danego procesu, nie jest jednoznaczna z wiedzą na temat tego,
dlaczego akurat te, a nie inne czynniki są tak ważne.

Czy próbowaliście przekonać kiedyś, kogoś do stosowania danej metody
tylko poprzez stwierdzenie, że: \quotation{powinniśmy stosować tę
metodę, bo z mojego doświadczenia wynika, że ona zadziała}? Albo:
\quotation{wszyscy tak robią i u nich działa, więc u nas też będzie -
spróbujmy}? Czasami się udaje, ale częściej mamy do czynienia ze zdrowym
sceptycyzmem.

Nasza ludzka natura często sprawia, że opieramy się temu, czego nie
rozumiemy. Rzeczy niezrozumiałe wręcz wzbudzają w nas poczucie strachu
przed nieznanym. Wystarczy spojrzeć na naszą mitologię i historię -
jeśli nie wiemy, jak i dlaczego coś działa, bardzo szybko przypisujemy
temu nadprzyrodzone moce - potrzebujemy wyjaśnienia.

Prawo Little'a jest dobrym wyjaśnieniem tego, dlaczego limit WIP i dobre
planowanie w Sprincie są tak ważne. Ale o tym za chwilę.

\subsection[zastosowanie-teorii-kolejek---kilka-bardziej-przyziemnych-przykładów]{Zastosowanie
Teorii Kolejek - kilka bardziej przyziemnych przykładów}

Zanim przejdziemy do rzeczy, chciałbym, abyście zastanowili się przez
chwilę nad odpowiedzią na poniższe pytania dotyczące utylizacji zasobów.

\startitemize
\item
  Jak wygląda autostrada zutylizowana w 100\%?
\item
  Jak działa komputer, w którym procesor jest wykorzystany w 100\%?
\item
  Jak efektywny jest zespół, którego zasoby czasowe są wykorzystane w
  100\%?
\stopitemize

Pracując ostatnio z jednym zespołów zauważyłem, że mają oni problem z
\quotation{dowożeniem} tego, co sobie zaplanują w Sprintach. Po kilku
Sprintach jasne dla mnie było, gdzie tkwi problem. Otóż zespół ten
przeważnie zbyt optymistycznie podchodził do Planowania Spintu.
Dodatkowo problemem było to, że praktycznie zawsze do Sprintu wpadało
coś z poprzedniej iteracji, co było \quotation{w połowie skończone}. Ten
nadmierny optymizm wynikał również z tego, że zespół praktycznie nie
robił Backlog Refinementu (Groomingu), więc planowanie polegało na
niekończących się dyskusjach o tym, co należy w danym zadaniu zrobić.
Zazwyczaj kończyło się to tym, że co najmniej połowa wymagań/zadań
polegała na \quotation{Researchu}. Jak dobrze wiecie - tego typu zadania
nie wnoszą zazwyczaj zbyt dużej wartości do produktu. Liczy się to, co
jest zaimplementowane i działa. Na pytania, dlaczego nie robią tego
\quotation{Researchu} podczas Backlog Refinementu (i dlaczego w ogóle
nie robią Refinementu, na który powinni przeznaczać do 10\% czasu w
Sprincie), odpowiedzią było oczywiście, że: \quotation{nie mają na to
czasu - przecież mają problem z dowożeniem tego co zaplanują, więc
dodatkowe spotkania w Sprincie mogą ten problem jedynie pogłębić}. Jak
zapewne zauważacie błędne koło się zamyka.

Udowadnianie bezsensowności takich działań zabrało mi sporo czasu, ale w
końcu udało się doprowadzić do sytuacji, w której zespół ten dowiózł
wszystko, co zaplanował po raz pierwszy w swojej historii. W następnym
Sprincie został już przewidziany czas na Refinement i od tej pory
wszystko zaczęło się (oczywiście z kilkoma potknięciami) układać tak,
jak powinno.

\subsection[teoria-kolejek-a-straty-w-wytwarzaniu-oprogramowania]{Teoria
Kolejek a straty w wytwarzaniu oprogramowania}

Analizując zastosowanie wzorów Teorii Kolejek i Prawa Little'a można
szybko wyciągnąć wniosek, że w każdym systemie kolejkowym można znaleźć
pewien stan (określony przez liczbę zadań wykonywanych w danej chwili),
w którym system ten działa najbardziej efektywnie. Podobnie dla każdego
zespołu developerskiego można wyliczyć (lub raczej podejść do tego
eksperymentalnie) pewną optymalną liczbę równolegle wykonywanych zadań.

Praktyka pokazuje, że liczba ta jest zazwyczaj mniejsza niż liczba osób
w zespole. Może to się wydawać nieintuicyjne. Bo przecież jak to? Ktoś
ma nie mieć przypisanego taska? I co ma robić - nudzić się, oglądać
filmiki na JoeMonster? Po pierwsze - inteligentni ludzie się nie nudzą,
po drugie, jeśli firma zatrudnia ludzi, którzy na każdym kroku szukają
okazji do tego, by oszukiwać swojego pracodawcę, to raczej ma większy
problem niż to, że zespół jest mało efektywny.

Mały eksperyment myślowy - czy zdarzyło Ci się kiedyś czekać na to, aż
ktoś zrobi Ci Code Review? Co wtedy zrobiłeś? Pewnie zacząłeś pracę nad
kolejnym zadaniem? Gdy ktoś akurat znalazł czas na Code Review, to Ty
już byłeś zajęty, więc Code Review odbyło się asynchronicznie poprzez
komentarze w kodzie lub, co gorsza, uwagi w mailu. Mało tego, wracając
do uwag po takim review musisz ponownie zmienić kontekst. Jak bardzo to
jest efektywne? A przecież wszyscy wiemy, że najlepsze jest Code Review,
podczas którego rozmawiamy o zmianach w kodzie i najlepiej, jeśli to
możliwe, od razu wprowadzamy poprawki i wspólnie poprawiamy jakość tego,
co zrobiliśmy. No, ale jak to osiągnąć, gdy wszyscy są skupieni na
swoich zadaniach i trzeba czekać na to, aż będą wolni? Albo Ty będziesz
musiał czekać, albo oni będą musieli zmienić kontekst. W obu przypadkach
któreś z wykonywanych zadań będzie czekało w kolejce i nie będzie w
danym momencie wykonywane - w Lean nazywamy to przestojem produkcyjnym i
jest to jeden z największych czynników generujących straty w procesie
wytwórczym.

Czy nie byłoby łatwiej, gdybyśmy zawsze mieli kogoś, kto nie pracuje w
danym momencie nad niczym konkretnym i może bardzo szybko przejrzeć
Twoje zmiany? Szczerze - nie wiem, jak będzie w przypadku Twojego
zespołu, ale z pewnością warto by było spróbować i zmierzyć wyniki
takiego eksperymentu.

\subsection[trochę-matematyki]{Trochę matematyki}

Prawo Little'a opisuje się zazwyczaj wzorem:

Średni czas przetwarzania = Liczba elementów w systemie * częstotliwość
napływania nowych elementów do systemu.

W kontekście Kanban i Lean software development (a także w Lean
Manufacturing) przyjmuje się często (nie do końca poprawne - o tym za
chwilę) założenie, że w stabilnym systemie częstotliwość napływania
nowych elementów do tego systemu jest równa częstotliwości, z jaką
elementy opuszczają ten system.

Czyli możemy przyjąć, że: Średni czas przetwarzania = WIP Limit *
średnia częstotliwość, z jaką zadania opuszczają system.

Więc przekształcając to równanie mamy:

Średnia częstotliwość, z jaką zadania opuszczają system = Średni czas
przetwarzania / WIP Limit

i

WIP Limit = Średni czas przetwarzania / średnia częstotliwość, z jaką
zadania opuszczają system.

Jak widzicie, możemy za pomocą tych wzorów określić, jaki powinien być
limit WIP, jeśli znamy średni czas przetwarzania i średnią
częstotliwość, z jaką zadania opuszczają system.

Wydaje się to być proste - więc dlaczego nie mamy do czynienia na co
dzień z super efektywnymi zespołami? Dlaczego jest tak wiele fabryk,
które nie są efektywne? Dlaczego system zutylizowany w 100\% nie jest
efektywny?

Odpowiedź jest prosta i jest związana z błędnym założeniem, że: *
wszystkie zadania mają dokładnie taką samą wielkość, więc nie tworzą się
kolejki * nie występują czynniki losowe, które wyprowadzają nasz system
ze stabilnego stanu

Czy możemy zatem coś z tym zrobić?

\subsection[proste-rozwiązanie]{Proste rozwiązanie}

Wielu managerów i dyrektorów oczekuje od swoich podwładnych tego, że
będą wykazywali inicjatywę, że będą innowacyjni, że będą się rozwijać i
usprawniać całą organizację - ja się tylko po cichu czasem pytam, kiedy
mają to robić, jeśli ich czas jest zaalokowany w 100\%?

Jak zatem zoptymalizować proces wytwarzania oprogramowania w każdej
organizacji? Kilkukrotnie już udało mi się z powodzeniem wykorzystać
pewną prostą metodę składającą się z kilku kroków: * Mierzymy przez
określony okres czasu (np. Sprint), ile mniej więcej zespół jest w
stanie skończyć zadań, albo Story Pointów, albo czegoś innego
mierzalnego (czyli Velocity w Scrum - tzw. \quotation{pojemność
zespołu}). Istotne jest to, by mierzyć tylko to, co jest skończone, a
nie \quotation{rozgrzebane}. * W następnej iteracji planujemy 80\% tego,
co udało się skończyć w poprzedniej. Jeśli uda się wszystkie zaplanowane
zadania skończyć przed końcem iteracji, to dobieramy kolejne, aż skończy
się iteracja. * W kolejnej iteracji powtarzamy poprzednie kroki - znowu
bierzemy 80\% tego, co udało się skończyć w poprzedniej iteracji.

Logika podpowiada Wam zapewne, że w ten sposób z iteracji na iterację
zespół będzie kończył coraz mniej zadań. Praktyka pokazuje jednak, że
zazwyczaj te 80\% rzeczy udaje się skończyć przed końcem iteracji i
zespół dobiera kolejne zadania. W efekcie często skutkuje to tym, że w
kolejnych iteracjach udaje się skończyć mniej więcej tyle samo, co w
poprzednich iteracjach. Czasem zdarza się, że uda się skończyć więcej i
średnie Velocity stopniowo rośnie.

\subsection[konkluzja]{Konkluzja}

Powiecie zapewne, że to u mnie nie zadziała. W naszej organizacji się
nie da. Nikt tego nie zrozumie. Nam ktoś każe brać cały czas więcej
etc\ldots{}

Jeśli, ktoś Wam każe brać więcej do Sprintu to zadajcie mu proste
pytanie: Czy chce abyście brali więcej, czy może jednak woli, żebyście
dowozili więcej?

Jeszcze na zakończenie trochę przemyśleń. Nieefektywność zespołu, czy
organizacji, to moim zdaniem problem kulturowy, wynikający z braku
podstawowej wiedzy na temat zarządzania, Teorii Kolejek i Teorii
Ograniczeń (ang. Theory Of Constraints) na wysokich poziomach w
organizacji (często tych najwyższych). Nie jest to nic nowego -
dokładnie te same błędy popełniano od czasów rewolucji przemysłowej. Mam
nadzieję, że Teoria Kolejek pomoże Wam, drodzy czytelnicy, szerzyć
wiedzę i racjonalne podejście do wytwarzania oprogramowania i
zarządzania organizacją. I pamiętajcie - nawet jeśli jesteście
\quotation{tylko} developerami, to nie od nikogo innego - tylko od Was
zależy, jak będziecie pracować, jakich narzędzi używać i na co
pozwolicie swojej organizacji. Pamiętajcie, że organizację zawsze można
zmienić, albo można zmienić organizację!

\subsection[źródła]{Źródła}

\startitemize
\item
  The Goal: A Process of Ongoing Improvement - Eliyahu M. Goldratt and
  Jeff Cox
\item
  https://www.youtube.com/watch?v=rSZWig173xM - Wprowadzenie do Teorii
  Kolejek
\item
  https://www.youtube.com/watch?v=VU8TUSnQ-vw - WIP limit i Prawo
  Little'a
\item
  https://dzone.com/articles/lean-tools-queuing-theory - Lean i Teoria
  Kolejek
\item
  http://irh.inf.unideb.hu/user/jsztrik/education/09/english/3f.html -
  Tablice wzorów w Teorii Kolejek
\item
  http://www.supositorio.com/rcalc/rcalclite.htm - Kalkulator przydatny
  w eksperymentach nad Teorią Kolejek
\item
  http://www.referenceforbusiness.com/encyclopedia/Pro-Res/Queuing-Theory.html
  - Wstęp do Teorii Kolejek
\item
  http://less.works/less/principles/queueing\letterunderscore{}theory.html
  - Zarządzanie kolejkami
\stopitemize


\stoptext
